#!/usr/bin/env node

import fs from 'node:fs/promises';
import path from 'node:path';
import readline from 'node:readline/promises';

import {
    Client,
    AccountId,
    PrivateKey,
    TransferTransaction,
    TransactionRecordQuery,
} from '@hashgraph/sdk';
import {
    HDNode as ethersHdNode,
} from '@ethersproject/hdnode';

import dotenv from 'dotenv';

dotenv.config();

// TODO read these in as CLI params
const NUM_ACCOUNTS = 2;
const AMOUNT_PER_ACCOUNT = 10;
const HD_PATH = "m/44'/60'/0'/0";

// Ensure required environment variables are available
if (!process.env.OPERATOR_ID ||
    !process.env.OPERATOR_KEY ||
    !process.env.SEED_PHRASE) {
    throw new Error('Must set OPERATOR_ID, OPERATOR_KEY, and SEED_PHRASE in .env');
}

// Configure client using environment variables
const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
const operatorKey = PrivateKey.fromStringED25519(process.env.OPERATOR_KEY);
const client = Client.forTestnet().setOperator(operatorId, operatorKey);

async function main() {
    console.log('Operator Account ID:', operatorId.toString());

    const hdNodeRoot = ethersHdNode.fromMnemonic(process.env.SEED_PHRASE);
    const accounts = new Array(NUM_ACCOUNTS);
    for (let idx = 0; idx < NUM_ACCOUNTS; idx++) {
        const accountHdPath = `${HD_PATH}/${idx}`;
        const hdNodeX = hdNodeRoot.derivePath(accountHdPath);

        // Convert private key from ethersjs format to hedera sdk format
        const privateKeyX = PrivateKey.fromStringECDSA(hdNodeX.privateKey);
        accounts[idx] = {
            id: '',
            evmAddress: privateKeyX.publicKey.toEvmAddress(),
            hdPath: accountHdPath,
            publicKey: privateKeyX.publicKey.toStringDer(),
            privateKey: privateKeyX.toStringDer(),
        };
        console.log(`#${idx} ${accountHdPath} EVM address: ${privateKeyX.publicKey.toEvmAddress()}`);
    }

    let multiTransferTx = new TransferTransaction()
        .addHbarTransfer(operatorId, (0 - AMOUNT_PER_ACCOUNT) * NUM_ACCOUNTS);
        accounts.forEach((account) => {
            // TransferTransaction's interface allows multiple operations until frozen
            multiTransferTx = multiTransferTx.addHbarTransfer(account.evmAddress, AMOUNT_PER_ACCOUNT);
        });
    multiTransferTx = multiTransferTx.freezeWith(client);
    const transferTxSign = await multiTransferTx.sign(operatorKey);
    const transferTxResponse = await transferTxSign.execute(client);
	const transferTxRecord = await transferTxResponse.getRecord(client);
    const transferTxId = transferTxRecord.transactionId;
    console.log('Transfer transaction ID', transferTxId.toString());

    const transferRecordQy = await new TransactionRecordQuery()
        .setTransactionId(transferTxId)
        .setIncludeChildren(true)
        .execute(client);

    const recipientExpectedAmountStr = BigInt(AMOUNT_PER_ACCOUNT * 100_000_000).toString();
    const recipientTransfers = transferRecordQy.transfers.filter((transfer) => {
        // Expect other receipts as well, who receive the fees paid for processing the transaction
        return (transfer.amount.toTinybars().toString() === recipientExpectedAmountStr);
    });
    if (recipientTransfers.length !== NUM_ACCOUNTS) {
        console.warn('WARNING: Unexpected number of recipient transfers:', recipientTransfers.length);
        console.log(transfers);
    }
    for (let idx = 0; idx < NUM_ACCOUNTS; ++idx) {
        accounts[idx].id = recipientTransfers[idx].accountId;
    }

    const startEnvFileFormat = [
        `OPERATOR_ID="${process.env.OPERATOR_ID}"`,
        `OPERATOR_KEY="${process.env.OPERATOR_KEY}"`,
        `SEED_PHRASE="${process.env.SEED_PHRASE}"`,
    ].join('\n');
    const accountsEnvFileFormat = accounts.map((account, idx) => {
        return [
            `ACCOUNT_${idx}_ID="${account.id}"`,
            `ACCOUNT_${idx}_EVMADDRESS="${account.evmAddress}"`,
            `ACCOUNT_${idx}_KEY="${account.privateKey}"`,
            `ACCOUNT_${idx}_PUBLICKEY="${account.publicKey}"`,
        ].join('\n');
    }).join('\n');
    const fullEnvFileFormat = [
        startEnvFileFormat,
        accountsEnvFileFormat,
        `# Generated by hedera-dev/hedera-code-snippets/bip39-create-accounts on ${(new Date()).toISOString()}\n`,
    ].join('\n\n');

    const envFilePath = path.resolve(process.cwd(), '.env');
    const envFileExists = await fileExists(envFilePath);
    let allowedOverwrite = false;
    console.log(`File at "${envFilePath}" exists: ${envFileExists}`);
    if (envFileExists) {
        const prompt = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
        });
        const inputStr = await prompt.question(`Do you wish to overwrite "${envFilePath}"? (y/N): `);
        allowedOverwrite = (inputStr.charAt(0).toUpperCase() === 'Y');
        prompt.close();
    }
    if (!envFileExists || allowedOverwrite) {
        console.log(`OK, .env file written to "${envFilePath}".`);
        fs.writeFile(envFilePath, fullEnvFileFormat);
    } else {
        console.log('OK, .env file contents output to console instead.');
        console.log(fullEnvFileFormat);
    }

    await client.close();
}

main();

async function fileExists(filePath) {
    try {
        return (await fs.stat(filePath)).isFile();
    } catch (e) {
        return false;
    }
}
